#|
 This file is a part of Classowary
 (c) 2019 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(defpackage #:org.shirakumo.classowary.test
  (:use #:cl #:parachute)
  (:local-nicknames
   (#:cass #:org.shirakumo.classowary)))
(in-package #:org.shirakumo.classowary.test)

(define-test classowary)

;;; Tests from the Amoeba implementation
(define-test all
  :parent classowary
  (let* ((solver (finish (cass:make-solver)))
         (xl (finish (cass:make-variable solver)))
         (xm (finish (cass:make-variable solver)))
         (xr (finish (cass:make-variable solver))))
    (false (cass:constrained-p NIL))
    (false (cass:suggestable-p NIL))
    (false (cass:suggestable-p xl))
    (false (cass:suggestable-p xm))
    (false (cass:suggestable-p xr))
    (fail (setf (cass:relation NIL) '>=))
    (let ((c1 (finish (cass:make-constraint solver))))
      (finish (cass:add-term c1 1f0 xl))
      (finish (setf (cass:relation c1) '>=))
      (finish (cass:add-constraint c1))

      (fail (setf (cass:relation c1) '>=) 'cass:assertion-violated)
      (finish (setf (cass:strength c1) (- cass:+REQUIRED+ 10)))
      (finish (setf (cass:strength c1) :required))

      (true (cass:constrained-p c1))
      (false (cass:suggestable-p xl))

      (let ((c2 (finish (cass:make-constraint solver))))
        (finish (cass:add-term c2 1f0 xl))
        (finish (setf (cass:relation c2) '=))
        (finish (cass:add-constraint c2))

        (finish (cass:reset-solver solver T))
        (finish (cass:delete-constraint c1))
        (finish (cass:delete-constraint c2))))
    
    (let ((c1 (finish (cass:make-constraint solver))))
      (finish (cass:add-term c1 2f0 xm))
      (finish (setf (cass:relation c1) '=))
      (finish (cass:add-term c1 1f0 xl))
      (finish (cass:add-term c1 1f0 xr))
      (finish (cass:add-constraint c1))

      (let ((c2 (finish (cass:make-constraint solver))))
        (finish (cass:add-term c2 1f0 xl))
        (finish (cass:add-constant c2 10f0))
        (finish (setf (cass:relation c2) '<=))
        (finish (cass:add-term c2 1f0 xr))
        (finish (cass:add-constraint c2))

        (let ((c3 (finish (cass:make-constraint solver))))
          (finish (cass:add-term c3 1f0 xr))
          (finish (setf (cass:relation c3) '<=))
          (finish (cass:add-constant c3 100f0))
          (finish (cass:add-constraint c3))

          (let ((c4 (finish (cass:make-constraint solver))))
            (finish (cass:add-term c4 1f0 xl))
            (finish (setf (cass:relation c4) '>=))
            (finish (cass:add-constant c4 0f0))
            (finish (cass:add-constraint c4))

            (let ((c5 (finish (cass:clone-constraint c4 :strength :required))))
              (finish (cass:add-constraint c5))
              (finish (cass:remove-constraint c5)))
            
            (let ((c5 (finish (cass:make-constraint solver))))
              (finish (cass:add-term c5 1f0 xl))
              (finish (setf (cass:relation c5) '=))
              (finish (cass:add-constant c5 0f0))
              (finish (cass:add-constraint c5)))

            (let ((c6 (finish (cass:clone-constraint c4 :strength :required))))
              (finish (cass:add-constraint c6))
              (finish (cass:reset-constraint c6))
              (finish (cass:delete-constraint c6)))

            (finish (cass:remove-constraint c1))
            (finish (cass:remove-constraint c2))
            (finish (cass:remove-constraint c3))
            (finish (cass:remove-constraint c4))

            (finish (cass:add-constraint c4))
            (finish (cass:add-constraint c3))
            (finish (cass:add-constraint c2))
            (finish (cass:add-constraint c1))
            (finish (cass:reset-solver solver NIL))
            (finish (cass:reset-solver solver T))
            
            (finish (cass:add-constraint c1))
            (finish (cass:add-constraint c2))
            (finish (cass:add-constraint c3))
            (finish (cass:add-constraint c4))
            
            (macrolet ((check-variables (l m r)
                         `(progn
                            (is = ,l (cass:value xl))
                            (is = ,m (cass:value xm))
                            (is = ,r (cass:value xr)))))
              (finish (cass:update-variables solver))
              (check-variables 90 95 100)

              (finish (cass:make-suggestable xm cass:+MEDIUM+))
              (finish (cass:update-variables solver))
              (check-variables 90 95 100)
              (true (cass:suggestable-p xm))

              (finish (cass:suggest xm 0f0))
              (finish (cass:update-variables solver))
              (check-variables 0 5 10)

              (finish (cass:suggest xm 70f0))
              (finish (cass:update-variables solver))
              (check-variables 65 70 75)

              (finish (cass:delete-edit xm))
              (finish (cass:update-variables solver))
              (check-variables 90 95 100))))))))

(defun make-constraint (solver strength term1 factor1 relation constant &rest vars)
  (let ((constraint (cass:make-constraint solver :strength strength)))
    (cass:add-term constraint factor1 term1)
    (setf (cass:relation constraint) relation)
    (when constant
      (cass:add-constant constraint constant))
    (loop for (var factor) on vars by #'cddr
          do (cass:add-term constraint factor var))
    (cass:add-constraint constraint)))

(define-test binary-tree
  :parent classowary
  (let* ((solver (cass:make-solver))
         (current-row-points-count 1)
         (current-row-first-point-index 0)
         (arrx (make-array 1024))
         (arry (make-array 1024)))
    (setf (aref arrx 0) (cass:make-variable solver))
    (setf (aref arry 0) (cass:make-variable solver))
    (cass:make-suggestable (aref arrx 0) cass:+STRONG+)
    (cass:make-suggestable (aref arry 0) cass:+STRONG+)
    (cass:suggest (aref arrx 0) 500f0)
    (cass:suggest (aref arry 0) 10f0)

    (loop for row from 1 below 9
          for previous-row-first-point-index = current-row-first-point-index
          for point = 0 and parent-point = 0
          do (incf current-row-first-point-index current-row-points-count)
             (setf current-row-points-count (* 2 current-row-points-count))
             (loop for point from 0 below current-row-points-count
                   do (setf (aref arrx (+ current-row-first-point-index point)) (cass:make-variable solver))
                      (setf (aref arry (+ current-row-first-point-index point)) (cass:make-variable solver))
                      (let ((pc (cass:make-constraint solver)))
                        (cass:add-term pc 1f0 (aref arry (+ current-row-first-point-index point)))
                        (setf (cass:relation pc) '=)
                        (cass:add-term pc 1f0 (aref arry (- current-row-first-point-index 1)))
                        (cass:add-constant pc 15f0)
                        (finish (cass:add-constraint pc)))
                      (cond ((< 0 point)
                             (let ((pc (cass:make-constraint solver)))
                               (cass:add-term pc 1f0 (aref arrx (+ current-row-first-point-index point)))
                               (setf (cass:relation pc) '>=)
                               (cass:add-term pc 1f0 (aref arrx (+ current-row-first-point-index point -1)))
                               (cass:add-constant pc 5f0)
                               (finish (cass:add-constraint pc))))
                            (T
                             (let ((pc (cass:make-constraint solver)))
                               (cass:add-term pc 1f0 (aref arrx (+ current-row-first-point-index point)))
                               (setf (cass:relation pc) '>=)
                               (cass:add-constant pc 0f0)
                               (finish (cass:add-constraint pc)))))
                      (when (= 1 (mod point 2))
                        (let ((pc (cass:make-constraint solver)))
                          (cass:add-term pc 1f0 (aref arrx (+ previous-row-first-point-index parent-point)))
                          (setf (cass:relation pc) '=)
                          (cass:add-term pc 0.5f0 (aref arrx (+ current-row-first-point-index point)))
                          (cass:add-term pc 0.5f0 (aref arrx (+ current-row-first-point-index point -1)))
                          (finish (cass:add-constraint pc))
                          (incf parent-point)))))
    (cass:update-variables solver)
    ;; (loop for i from 0 below (+ current-row-first-point-index current-row-points-count)
    ;;       do (format T "Point ~d: (~f, ~f)~%" i (cass:value (aref arrx i)) (cass:value (aref arry i))))
    ))

(define-test unbound
  :parent classowary
  (let* ((solver (cass:make-solver))
         (x (cass:make-variable solver))
         (y (cass:make-variable solver)))
    (let ((c (cass:make-constraint solver)))
      (cass:add-constant c 10)
      (setf (cass:relation c) '=)
      (fail (cass:add-constraint c) 'cass:expression-unsatisfied))
    (let ((c (cass:make-constraint solver)))
      (cass:add-constant c 0)
      (setf (cass:relation c) '=)
      (finish (cass:add-constraint c)))
    (cass:reset-solver solver T)
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 x)
      (setf (cass:relation c) '>=)
      (cass:add-constant c 10)
      (finish (cass:add-constraint c)))
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 x)
      (setf (cass:relation c) '=)
      (cass:add-term c 2 y)
      (finish (cass:add-constraint c)))
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 y)
      (setf (cass:relation c) '=)
      (cass:add-term c 3 x)
      (fail (cass:add-constraint c) 'cass:expression-unbound))
    (cass:reset-solver solver T)
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 x)
      (setf (cass:relation c) '>=)
      (cass:add-constant c 10)
      (finish (cass:add-constraint c)))
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 x)
      (setf (cass:relation c) '<=)
      (fail (cass:add-constraint c) 'cass:expression-unbound)
      (is = 10 (cass:value x)))
    (cass:reset-solver solver T)
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 x)
      (setf (cass:relation c) '=)
      (cass:add-constant c 10)
      (finish (cass:add-constraint c)))
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 x)
      (setf (cass:relation c) '=)
      (cass:add-constant c 20)
      (fail (cass:add-constraint c) 'cass:expression-unsatisfied))
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 x)
      (setf (cass:relation c) '=)
      (cass:add-constant c 10)
      (finish (cass:add-constraint c)))))

(define-test strength
  :parent classowary
  (let* ((solver (cass:make-solver :auto-update T))
         (x (cass:make-variable solver))
         (y (cass:make-variable solver)))
    (make-constraint solver :strong x 1 '<= 0 y 1)
    (make-constraint solver :medium x 1 '= 50)
    (let ((c (make-constraint solver (- cass:+MEDIUM+ 10) y 1 '= 40)))
      (is = 50 (cass:value x))
      (is = 50 (cass:value y))
      (setf (cass:strength c) (+ cass:+MEDIUM+ 10))
      (is = 40 (cass:value x))
      (is = 40 (cass:value y))
      (setf (cass:strength c) (- cass:+MEDIUM+ 10))
      (is = 50 (cass:value x))
      (is = 50 (cass:value y)))))

(define-test suggest
  :parent classowary
  (let* ((width 76)
         (delta 0)
         (pos)
         (solver (cass:make-solver))
         (splitter-l (cass:make-variable solver))
         (splitter-w (cass:make-variable solver))
         (splitter-r (cass:make-variable solver))
         (left-child-l (cass:make-variable solver))
         (left-child-w (cass:make-variable solver))
         (left-child-r (cass:make-variable solver))
         (splitter-bar-l (cass:make-variable solver))
         (splitter-bar-w (cass:make-variable solver))
         (splitter-bar-r (cass:make-variable solver))
         (right-child-l (cass:make-variable solver))
         (right-child-w (cass:make-variable solver))
         (right-child-r (cass:make-variable solver)))
    (make-constraint solver :required splitter-r 1 '= 0
                     splitter-l 1 splitter-w 1)
    (make-constraint solver :required left-child-r 1 '= 0
                     left-child-l 1 left-child-w 1)
    (make-constraint solver :required splitter-bar-r 1 '= 0
                     splitter-bar-l 1 splitter-bar-w 1)
    (make-constraint solver :required right-child-r 1 '= 0
                     right-child-l 1 right-child-w 1)
    
    (make-constraint solver :required splitter-bar-w 1 '= 6)
    (make-constraint solver :required splitter-bar-l 1 '>=
                     delta splitter-l 1)
    (make-constraint solver :required splitter-bar-r 1 '<=
                     (- delta) splitter-r 1)
    (make-constraint solver :required left-child-r 1 '= 0
                     splitter-bar-l 1)
    (make-constraint solver :required right-child-l 1 '= 0
                     splitter-bar-r 1)

    (make-constraint solver :required right-child-r 1 '>= 1
                     splitter-r 1)
    (make-constraint solver :required left-child-w 1 '= 256)

    (make-constraint solver :required splitter-l 1 '= 0)
    (make-constraint solver :required splitter-r 1 '= width)

    (loop for pos from -10 below 86
          do (cass:suggest splitter-bar-l pos)
             (cass:update-variables solver)
             (is =   0 (cass:value splitter-l))
             (is =  76 (cass:value splitter-w))
             (is =  76 (cass:value splitter-r))
             (is = 256 (cass:value left-child-w))
             (is =   6 (cass:value splitter-bar-w))
             (is =  77 (cass:value right-child-r)))))

(define-test cycling
  :parent classowary
  (let* ((solver (cass:make-solver))
         (va (cass:make-variable solver))
         (vb (cass:make-variable solver))
         (vc (cass:make-variable solver))
         (vd (cass:make-variable solver)))
    (cass:make-suggestable va :strong)
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 vb)
      (setf (cass:relation c) '=)
      (cass:add-term c 1 va)
      (finish (cass:add-constraint c)))
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 vb)
      (setf (cass:relation c) '=)
      (cass:add-term c 1 vc)
      (finish (cass:add-constraint c)))
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 vc)
      (setf (cass:relation c) '=)
      (cass:add-term c 1 vd)
      (finish (cass:add-constraint c)))
    (let ((c (cass:make-constraint solver)))
      (cass:add-term c 1 vd)
      (setf (cass:relation c) '=)
      (cass:add-term c 1 va)
      (finish (cass:add-constraint c)))
    (is = 0 (cass:value va))
    (is = 0 (cass:value vb))
    (is = 0 (cass:value vc))
    (is = 0 (cass:value vd))))
